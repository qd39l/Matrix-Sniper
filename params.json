{"name":"ECE3140 Final Project - Wow! The Matrix Sniper","tagline":"Owen Deng (qd39) & Yang Shen (ys656)","body":"# Wow! The Matrix Sniper Beta\r\n\r\n## Introduction\r\n\r\nOur project for ECE 3140 SP20 is a laser shooting arcade game using the FRDM-K64F board as the control unit. In this game, there are 2 LED matrix panels that are the “targets” and a 7-segment LED number display that shows the player’s current score and tells the player which target to shoot on. \r\n\r\nAfter turning on the power supply, the LED panels would light up, and the 7-segment display would show the current score, which should be “0  0.” The number on the left shows the number of failures, and the number on the right shows the number of points. After ~10 seconds of waiting time for the player to get ready, the LED panels and the 7-segment display would flash for 3 seconds to signal the beginning of the game. At this point, the LED panels are turned off. After a random delay time, the board randomly picks one of the targets, the LED panels would flash, and the 7-segment display would show “ [ [ [ [ (left target)” of “] ] ] ] (right target).” If the player shoots the correct LED panel within a given amount of time, 1 point is scored. Otherwise, if the player shoots at the incorrect target or fails to shoot at the target within the given time, the player will lose 1 point and get 1 failure. After each round, the 7-segment display updates the current score. \r\n\r\nThe game ends when the player wins the game by scoring 5 points or making 2 failures. When the game ends, both LEDs are turned on. If the player wins, the number on the left (showing failures) would flash “2”. Otherwise, the number on the right (showing points) would flash “5”.\r\n\r\nWe have successfully assembled and coded the project to achieve full functionality. Through working on this project, we had the opportunity to design a project on our own, which inspired our imagination and sparked our passion. We have encountered a lot of difficulties and overcame them as true engineers. As a CS major, Yang learns basic knowledge of circuits, while Owen gets to learn software testing techniques from Yang. Furthermore, both of us learn how to collaborate remotely and work efficiently as a team, and we learn how to read the documentation of the hardware devices that we are working with and how to search for information from the internet. This project has given us great hands-on experience and encouraged us to think on our own, code on our own, and debug on our own, which will help us in our future careers!\r\n\r\n\r\n## System Overview\r\n\r\n### Block Diagram\r\n\r\n![](https://raw.github.coecis.cornell.edu/ece3140-sp2020/qd39-ys656/gh-pages/images/Block%20Diagram.png?token=AAAB5RWSWPC7EQIEN727I6K62WFZG)\r\n\r\nFig. 1. Hardware block diagram of the Matrix Sniper project.\r\n\r\nFig. 1 shows the block diagram of our project. Target 0 and Target 1 represents two LED matrix panels. Since the LED panels need to a) turn on and off the LEDs to communicate with the user, and b) to detect laser signals, each panel needs to both receive output and send input to the board. They are connected to the FRDM-K64F board where Target 0 is connected via GPIO-D0 pin for output and ADC0-DP0 pin for input, and Target 1 is connected via GIPO-C4 pin for output and ADC1-DP0 pin for input. Additionally, the 7-segment display which displays the score is also connected to the FRDM-K64F board with I2C protocol (uses I2C0 with PTE24 with SCL and PTE25 with SDA). In our implementation, the board only sends control signals to the LED panels and the 7-segment display, while a 5V power supply is used to deliver power for all hardware units. For debugging purposes, the board is also connected to the computer through USB serial, but it has no functional purposes in the game.\r\n\r\n### Circuit Diagram\r\n\r\n![](https://raw.github.coecis.cornell.edu/ece3140-sp2020/qd39-ys656/gh-pages/images/Circuit%20Diagram.png?token=AAAB5RTMERIABPQ5BCXD6QC62WF7W)\r\n\r\nFig. 2. Circuit diagram of one “target” LED panel.\r\n\r\nFig. 2 shows the circuit diagram of one of the “target” LED panels. One panel has 18 LEDs connected in parallel. Each LED is in series with a 470-Ohms resistor to limit the voltage drop on one LED. Another 470-Ohms resistor is connected in series with all LEDs to control the brightness. A 2N5551 NPN BJT is used to control the on/off of the LEDs. A 220-Ohms resistor is connected to the GPIO port to apply extra protection in case the BJT breaks down. Same with the GPIO port, the ADC port uses a 220-Ohms resistor for protection, and a 1-MOhms resistor is connected to ground to limit current on the measurement branch. The board has common ground with the above circuit to provide accurate readings of the ADC.\r\n\r\nIn case the above embedded video does not play as intended, here is a link to the video: https://www.youtube.com/PombbTEN6Gc\r\n(By May 25: Video is processing by Youtube, should be available within two days.)\r\n\r\n## System Description\r\n\r\n### Overall System\r\nOur overall system design involves the FRDM-K64F development board as the main control unit that runs all the code needed for this project. There are mainly two kinds of additional hardware units required: the 7-segment display and the LED “target” panels. The hardwares interact with the board with on-board control units: GPIO, I2C, and ADC. Specific information regarding hardware and software will be discussed in sections below.\r\n\r\n### Hardwares\r\nFig. 1 shows how our hardwares interact with the software on the board. There is one 7-segment LED display obtained from Adafruit. (link: https://www.adafruit.com/product/1269) The specific one that we are using is a 1.2’’ 4-digit display with I2C backpack. As its name indicates, this backpack uses a driver chip that provides an easy-to-use I2C interface. Information regarding the HT16K33 LED controller driver chip can be found here: https://cdn-shop.adafruit.com/datasheets/ht16K33v110.pdf. Because this LED backpack comes in assembled, we will treat it as one unit with an I2C interface in our discussion. With the provided I2C interface, we can write data into the system setup registers, the display setup registers, and we can control each of the segments on the display by writing the display data registers. By changing bits in the system setup registers and the display setup registers, we can control the brightness and the blinking rate of the LED segments. \r\n\r\nAs for the LED panels, Fig. 2 shows the circuit diagram for one of the LED panels. LEDs can generate ~1V terminal voltage when a laser beam shoots on it. This is why we can use the LED matrix to act both as the target and the sensor. The actual connection is shown in Fig. 3. On Fig. 3, the white wire connects the base of the BJT and the GPIO pin on the board to turn on/off the LEDs. The yellow wire connects the circuit with the ADC pin that measures the voltage drop on the LEDs. The brown wire connects the circuit with the cathode of the LEDs. As described in relevant sections in System Overview above, there are resistors used to limit the voltage drop on the LEDs, to protect the GPIO and ADC pins, and to adjust the brightness of the LEDs. There are two of these circuit units in the overall circuit because we have two LED panels.\r\n\r\n![](https://raw.github.coecis.cornell.edu/ece3140-sp2020/qd39-ys656/gh-pages/images/Connection%20Diagram.jpg?token=AAAB5RSUAXO3FE3OSURNQ2262WGBU)\r\n\r\nFig. 3. Connection diagram of one LED matrix control circuit.\r\n\r\nFig. 4 shows the wiring of the LED matrix used. A protoboard is used to fix the LEDs into place. All the anodes of the LEDs are soldered together, and each of the cathodes of the LEDs is soldered with a ~470-Ohms resistor. The resistors are then soldered together into one node. The measured current when one LED matrix is turned on is approximately 6 mA.\r\n\r\n![](https://raw.github.coecis.cornell.edu/ece3140-sp2020/qd39-ys656/gh-pages/images/LED%20matrix.jpg?token=AAAB5RQ3RMNNVS7ZRICYDDC62WGDS)\r\n\r\nFig. 4. Wiring of the LED matrix.\r\n\r\n### Software\r\nAll the files needed are submitted through CMS and pushed to our GitHub repo. The project on Keil is set up following the instructions for I2C tutorial on ECE3140 SP20 canvas. This means we need to have fsl_clock.c, fsl_common.c, fsl_gpio.c, and fsl_i2c.c included in our project. Our code loosely follows the Google style guide, and it is self-contained and well documented. Our main program for the game is contained in the main() function in main.c. We make use of the 3140_serial, 3140_i2c, and the utils library provided by course staff in our project. Functions and definitions involved in hardware control have their own C files and header files. The file sevenseg.c contains functions related to controlling the 7-segment display. The file adc.c contains functions related to setting up and reading the ADC values. The file gpio_ctr.c contains functions related to the GPIO pins that control the LED panels. \r\n\r\nIn the beginning of our code, we initialize all the hardwares with functions defined in our hardware control libraries. Then it clears the 7-segment display and shows current scores (which should be 0, 0). Then it turns on both the LED panels and waits for approximately 6 seconds before turning them off. Waiting is achieved using an empty for loop. After that, the program waits for another 4 seconds before starting the game. Our program then uses the sevenseg_blinkrate() function along with the GPIO control functions to flash the 7-segment display and the LED panels to signal the starting of the game. \r\n\r\nWhen the game starts, the random function is seeded with readings from an ADC pin, which should read a relatively random number. Then it enters a while loop. Inside the while loop, a random number is first generated with the rand_btw() function. This function takes in two integers, low and high, as arguments and returns a random number between low and 9 * (high - low) with low-high being the “quantum” of the possible returned values. This value is used to determine the random delay time length. The random delay in real-time is between 1 second and 15 seconds. After the random delay, the program uses rand() % 2 to generate a number of either 1 or 0, deciding the correct target that should be shot on. Then we use sevenseg_writeTarget() to update the pixels on the target so that it tells the player which target is the correct one. After doing that, the program uses the detect() function, which takes in two integer arguments. The first argument stands for how many reads the ADC should perform between each LED flash. The second argument stands for the correct target (either 0 or 1). The detect() function returns 1 if the player shoots at the correct target, and 0 otherwise. The program then updates the failures and scores global variables, and updates the 7-segment display to show the current scores and failures. If the player wins (current score = t_score top score) or the player loses (failures = t_failures top failures), the loop would break, otherwise, the game continues.\r\n\r\nAfter the game ends, the 7-segment display would blink the top failures or top scores, and both LED panels are turned on to signal the end of the game.\r\n\r\n#### Detect() function explain\r\nThe detect() function is an essential part of understanding our code because it is tricky. Therefore, it is important that we explain it here. When detect() is called, the function enters a for loop which iterates for 20 times. In each iteration, it first turns both targets on, then it delays for a very short time and does read_times (the first argument) times of trivial readings from the ADC with the trivial_read(read_times) function. After that, it turns the LED panels off. After another short wait, it reads from the read_and_detect() function which returns 0 when no laser signal is detected, 1 when the correct target senses the laser signal, and 2 when the incorrect target senses the laser signal. The function returns 0 if read_and_detect() returns 1 (correct target), and returns 0 if read_and_detect() returns 2 (incorrect target). If no laser signal is sensed (read_and_detect() never returns 1 or 2) when the for loop ends, the function returns 0 because it also counts as a failure.\r\n\r\nIn the read_and_detect() function, the program enters a for loop that iterates read_times times in the beginning. In each iteration, it reads values from ADCs connected to target 0 and target 1 to see if a laser signal is received. If a signal is received (the ADC reading exceeds a certain threshold), the function returns 1 or 2 depending on the correctness of the target. Otherwise, the function returns 0.\r\n\r\n#### 7-segment display control\r\nTo understand our sevenseg library, it is essential to explain how the I2C interface of the HT16K33 driver chip works. The chip has an I2C address 0x70. The system oscillator, blink rate, and brightness are controlled by writing bytes directly to the I2C address. Each digit on the display has a unique register address. The addresses are 0x00, 0x02, 0x06, and 0x08 counting from left to right. The byte that we are writing into this address follows the gfedcba format (see Fig. 5 for the corresponding segments), wich 1 being “on” and 0 being “off.” Note that the first bit must be set to 1 for the display to work appropriately because the first bit controls the decimal point. Otherwise, the data is interpreted differently. We use the 3140_i2c library to write to the driver chip through I2C.\r\n\r\n![](https://raw.github.coecis.cornell.edu/ece3140-sp2020/qd39-ys656/gh-pages/images/7-segment%20display.png?token=AAAB5RUHX5NB5YQIIY2WDTS62WGFQ)\r\n\r\nFig. 5. The individual segments of a seven-segment display. Figure obtained from wikipedia “Seven-segment display.” \r\n\r\n## Testing\r\n\r\n### Testing strategies\r\nOur project is broken into modules so that a) it makes us easier to collaborate remotely, and b) it makes testing much easier. Whether it is software or hardware that we are testing, we break down the project into small pieces and test them individually first before doing any assembling. Specific examples will be provided in the subsections below. After the final assembly, we take the module into different environments to make sure our project is robust enough to function under different lighting conditions that could generate random noise to our LED detection circuit. As for software, we mainly use the Keil debugger and the USB serial with PuTTY on the computer to view integer values that are of interest to us.\r\n\r\n### Hardware testing\r\nSince all hardware interactions use different pins on the board, we have the privilege to test them individually. Yang first built an LED detection circuit with the ADC (without GPIO control) and tested its functionality with a DMM to make sure distinguishable voltage drop appears before/after applying the laser beam on it. After making sure our detection method works, Yang wrote codes for setting up the ADCs and the GPIOs and used DMM and a 1.5 V battery to make sure these components on the board are set up correctly and work as expected. Then she assembled the LED input/output circuit with both the ADC and GPIO on the board and tested the overall functionality of the LED control circuit with only 1 LED. After that, she wrote the GPIO and ADC library and tested the library with the same circuit to make sure that also works. In the end, Owen assembled the two LED panels with all the LEDs needed and performed an overall hardware testing of the LED panels. Note that in the process of soldering, Owen also performed periodic checks on the connection of the circuit using batteries to make sure the LEDs have good connections.\r\n\r\nOn the other side, Owen first tested the Adafruit 7-segment display with an Arduino. He used the provided Arduino library to first make sure the hardware of the 7-segment display functions well. Then Owen wrote fragments of code to test the functionality of the 7-segment display with the FRDM-K64F board. After making sure all the controls work, Owen assembled the 7-segment display with the board and tested the sevenseg library. At this point, all the hardwares interactions are fully tested, and there is only software testing needed.\r\n\r\n### Software testing\r\nBecause our algorithm on the software part is relatively simple and has well-defined behavior, the Keil debugger and USB serial communication with the 3140_serial library serves well in showing values that we want to inspect. The gameplay procedures are also broken into pieces so that we can test them individually. First, Owen tested the functionality of the detect() function as well as the helper functions read_and_detect() because those two go into the core of our algorithm. Normally they function as intended, but when software bugs are encountered, Owen uses the customized print_num() helper function to see the values of related variables. After that, Owen adjusts the appropriate read_times and delay times to put the software into one part. At the end, Owen runs several trials of the game to ensure proper overall functionality. Note that whenever a new helper function is added, testing is performed before putting it into use. Yang did most of the testing that does not need hardware involvements, and Owen did all the testing that requires hardware interactions. \r\n\r\nThere are two corner cases worth mentioning (because they are very tricky!).\r\n\r\n#### Corner Case: Trivial Reading\r\nValid detection of the voltage drop across the LEDs through the ADC can only be performed when the LEDs are turned off. When the LEDs are turned on, the BJT is also turned on, so there is a 5V voltage drop across the LEDs, and readings from the ADC at this stage is invalid. This is because there are large recombinations happening in the quantum well when the LED is turned on, and interband transitions triggered by the laser are negligible. Also because the period of the on/off of the LEDs during the detection stage of the game is controlled by how many times a read action is performed on the ADCs, we need a way to make sure the same CPU cycles are used during the ON period when the ADC should not be reading and the OFF period when the ADC should be effectively reading. This is achieved with the trivial_read() function which takes the read_times as the argument. It has exactly the same structure as read_and_detect(), except that a very large threshold is used so that the “player does not shoot at anything” action is always returned (always return 0). In this way, in detect() we call trivial_read(read_times) when the GPIO pins are driven high, and read_and_detect(read_times, target) when the GPIO pins are driven low. This provides a hacky way to work around the problem.\r\n\r\n#### Corner Case: Parasitic Capacitance\r\nThe LEDs and the resistors (also the BJTs) have a parasitic capacitance which would be negligible when we are controlling by hand. However, this becomes significant when the LEDs are connected in parallel and when we are turning the LEDs on and off relatively frequently. When the LEDs switch from high to low, charge stored in the effective capacitors also needs to discharge. Therefore, the ADC would read a large number above the set threshold even when the laser is not shot on it if we perform read actions on the ADC immediately after the LEDs are turned off. To accommodate this issue, we added a short delay time with an empty for loop after each time the LEDs are turned on and off before performing the subsequent ADC readings.\r\n\r\n\r\n## Work Distribution\r\n\r\nOwen has all the hardware needed for this project, while Yang has some components but not all. Therefore, Yang first worked on setting up and testing the GPIO and ADC pins for a prototypical 1-LED detection circuit on her side, and Owen looked at the I2C protocol and the 7-segment display control. After Yang had that working and wrote the GPIO and ADC libraries, Owen assembled the LED panels and tested it. Then Owen started working on the detect() function while Yang started to work on the remaining of the main program. After assembling all the hardware, Owen and Yang worked together to finish the software part and additional testing. Then Owen made the video, while Yang updated the Github page write-up. After Owen finished, he joined to collaborate with the write-up. If one member gets ahead of the schedule, he/she would help with the progress that the other member is making so that both members are on the same page at all stages of the development. \r\n\r\nWe tried to follow the pair-programming convention that we have been doing from lab 3 to lab 5 as much as possible, especially when we worked on the final assembly of the software. Communication and collaboration were mainly through meeting in zoom. When we encountered difficulties, we discussed our ideas on the solution to reach an agreement before taking action. Both team members would work on the difficulties because we figured this helped us understand the system as a whole, and it is more efficient in solving problems when we work as a team. When writing codes, we had shared-screen on and boards next to us so that we could rapidly test and debug our code. When one was writing code, the other reviewed the line of code written. This minimized potential bugs in the project and also propels communication.\r\n\r\nOwen and Yang both believed that they work well as a team. They are happy to have each other as partners in this semester.\r\n\r\n## Resources\r\n\r\nThe LED panel design and circuit design in the final project is inspired by\r\nhttps://www.instructables.com/id/Arduino-Shooting-Game-Arcade/.\r\n\r\nAdditional hardware components include 36 Ultrabright Red LEDs, one 7-segment display from Adafruit, one 5V power source, several jumper wires, resistors (38 * ~470 Ohms, 6 * 220 Ohms, 2 * 1 MOhms), breadboard, green laser pen, two protoboards, two 2N5551 NPN BJTs.\r\n\r\nIn our code, we have also used 3140_serial and 3140_i2c libraries provided. We implemented all other libraries and the main function used on our own.\r\n\r\n## Acknowledgements\r\n\r\nWe would like to thank the instructor and all the course staff for their dedication to this course! \r\n\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}